// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.65.0.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';

abstract class Native {
  Future<DocumentId> openDoc(
      {required String path, required int initialChapter, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOpenDocConstMeta;

  Future<ContentBlock> goNext({required DocumentId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGoNextConstMeta;

  Future<ContentBlock> goPrev({required DocumentId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGoPrevConstMeta;

  Future<ContentBlock> getContent({required DocumentId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetContentConstMeta;

  Future<Uint8List> getResource(
      {required DocumentId id, required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetResourceConstMeta;

  Future<String> auth({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAuthConstMeta;

  Future<void> poll({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPollConstMeta;

  Future<void> sync2({required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSync2ConstMeta;

  Future<Database> initDb({required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kInitDbConstMeta;

  /// Returns the metadata that might be useful in a "bookshelf" view
  Future<Meta> getMeta({required String id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetMetaConstMeta;

  Future<void> clearDb({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kClearDbConstMeta;

  Future<Definitions> getDefinition({required String word, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetDefinitionConstMeta;

  Future<List<Book>> addBookMethodDatabase(
      {required Database that, required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddBookMethodDatabaseConstMeta;

  Future<void> updateProgressMethodDatabase(
      {required Database that,
      required String id,
      required int chapter,
      required double offset,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUpdateProgressMethodDatabaseConstMeta;

  Future<List<Book>> getBooksMethodDatabase(
      {required Database that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetBooksMethodDatabaseConstMeta;
}

class Book {
  final String uuid;
  final String path;
  final Position position;
  Book({
    required this.uuid,
    required this.path,
    required this.position,
  });
}

class ContentBlock {
  final String content;
  final ContentType contentType;
  ContentBlock({
    required this.content,
    required this.contentType,
  });
}

enum ContentType {
  Text,
  Html,
}

class Database {
  final Native bridge;
  Database({
    required this.bridge,
  });

  Future<List<Book>> addBook({required String path, dynamic hint}) =>
      bridge.addBookMethodDatabase(
        that: this,
        path: path,
      );

  Future<void> updateProgress(
          {required String id,
          required int chapter,
          required double offset,
          dynamic hint}) =>
      bridge.updateProgressMethodDatabase(
        that: this,
        id: id,
        chapter: chapter,
        offset: offset,
      );

  Future<List<Book>> getBooks({dynamic hint}) => bridge.getBooksMethodDatabase(
        that: this,
      );
}

class Definition {
  final String definition;
  final String? example;
  final List<String> synonyms;
  Definition({
    required this.definition,
    this.example,
    required this.synonyms,
  });
}

class Definitions {
  final String word;
  final List<Meaning> meanings;
  Definitions({
    required this.word,
    required this.meanings,
  });
}

class DocumentId {
  final int field0;
  DocumentId({
    required this.field0,
  });
}

class Meaning {
  final String partOfSpeech;
  final List<Definition> definitions;
  Meaning({
    required this.partOfSpeech,
    required this.definitions,
  });
}

class Meta {
  final String? title;
  final String? author;
  final Uint8List? cover;
  Meta({
    this.title,
    this.author,
    this.cover,
  });
}

class Position {
  final int chapter;
  final double offset;
  Position({
    required this.chapter,
    required this.offset,
  });
}
